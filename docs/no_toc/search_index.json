[["index.html", "Course Name About this Course 0.1 Available course formats", " Course Name September, 2023 About this Course 0.1 Available course formats This course is available in multiple formats which allows you to take it in the way that best suites your needs. You can take it for certificate which can be for free or fee. The material for this course can be viewed without login requirement on this Bookdown website. This format might be most appropriate for you if you rely on screen-reader technology. This course can be taken for free certification through Leanpub. This course can be taken on Coursera for certification here (but it is not available for free on Coursera). Our courses are open source, you can find the source material for this course on GitHub. "],["introduction.html", "Chapter 1 Introduction 1.1 Motivation 1.2 Target Audience 1.3 Curriculum", " Chapter 1 Introduction 1.1 Motivation 1.2 Target Audience The course is intended for … 1.3 Curriculum The course covers… devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-09-08 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["command-line-seminar.html", "Chapter 2 Command Line Seminar 2.1 What is the Command Line and why should I learn it? 2.2 Getting Started 2.3 Mental Model 1: Navigating a directory tree 2.4 Mental Model 2: Treat text-based programs as functions 2.5 Putting the two mental models together: file manipulation 2.6 Applying what we just learned: running bioinformatics software 2.7 Bonus: Redirects and Pipes 2.8 Appendix: Special symbols for directories: 2.9 Appendix: Why do we run some programs using ./? 2.10 Appendix: using a text editor in CLI 2.11 Session info", " Chapter 2 Command Line Seminar 2.1 What is the Command Line and why should I learn it? Let’s think about the ways we can interact with a computer: keyboard and mouse, hand gestures on a smartphone, voice commands, AR/VR, etc. Most of these interactions are related to a Graphical User Interface (GUI), which centers on the interaction between a pointer and colorful windows and menus. However, the way a computer interprets and executes instructions are based on text commands. Even graphical information, such as where the mouse is when it clicked a button, is converted into numbers and characters. That means to be an effective programmer and data scientist, we also need to learn how to interact with our computers in a text-based way. This text-based interaction is called the Command Line Interface (CLI). Examples where we need to use the Command Line: Scalable manipulation of text, files, and folders: if we want to move all files that have the words “tax returns” to a new folder, it would probably not scale easily via a mouse, but it could be done in one command in the Command Line. Use of programming languages and scientific software tools often require Command Line knowledge: running Python and R programs, using Git, alignment and variant calling bioinformatics software. Although there are nice graphical user interfaces such as RStudio, Juypter Notebooks, and Galaxy, to have full flexibility of these languages you need to control them from the Command Line. Use to high performance computing systems and the cloud all require Command Line knowledge as they do not typically offer GUIs. The most commonly used Command Line is the Shell. The Shell is a dynamic programming environment, similar to R and Python, but focuses on interacting with the operating system. 2.2 Getting Started Open your Shell: on Macs, open up “Terminal” Application. On Windows, open up xxx. You should see a single line of text, with a blinking cursor, such as this: andrew@MGQQR2YQRT9 ~ % Here, andrew is the computer user, and MGQQR2YQRT9 is the computer’s name. The next piece of character, ~ states that the currently directory is ~. The symbol ~ is a short-hand for the “home” directory for the user of a computer. On Macs, it would be something like /User/andrew. This current directory is important: in the Command Line, you interact with the computer from a directory, similar interacting with the computer using a file system window graphically. To confirm that you are in “home” directory, type in the command pwd and hit enter. andrew@MGQQR2YQRT9 ~ % pwd /Users/andrew Unlike a GUI, the CLI does not provide immediate options to you to interact with. We have to know a learn a handful of vocabulary to interact with it well. But besides the vocabulary, we need to keep a mental model of a task we want to complete. In GUIs that that mental model is shown to us visually, such as a file browser. We organizes our seminar by constructing several mental models and learning relevant commands related to each model. Lastly, the CLI is forgiving. It will tell you if you did something you did not intend to, with little consequences, which encourages exploration and experimentation. Consequential actions have security safeguards. With this mindset, we will explore the CLI openly. 2.3 Mental Model 1: Navigating a directory tree On our computer, the file system organizes files and directories in an (upside down) tree-like structure. In each folder, there is a parental directory, and there can be files and directories within it. The root directory / does not have a parental directory and contains all directories and files in on the computer. Below is a typical directory tree schematic, with the root directory being / and home directory being /Users/andrew/. We refer to a particular directory by describing its directory path separated by / slashes. Directory Tree example with user “andrew”. To interact with files and programs in the file system in the GUI world, we moved up and down the directory tree via point and clicking on windows. In the CLI world we can use the following commands: pwd prints out our current directory. cd / changes directory to the root directory. cd /Users/andrew changes directory to the home directory. Consider: andrew@MGQQR2YQRT9 ~ % cd /Users/andrew andrew@MGQQR2YQRT9 ~ % pwd /Users/andrew So far, we have changed the directory by specifying the absolute directory path, which means specifying the directory from the root directory /. Often, we can specify a path by the relative directory path, which is a path relative to our current directory. Consider: andrew@MGQQR2YQRT9 ~ % pwd /Users/andrew andrew@MGQQR2YQRT9 ~ % cd Desktop/ andrew@MGQQR2YQRT9 Desktop % pwd /Users/andrew/Desktop andrew@MGQQR2YQRT9 Desktop % cd .. andrew@MGQQR2YQRT9 ~ % pwd /Users/andrew We started in /Users/andrew, and then changed to /Users/andrew/Desktop by specifying cd Desktop/ as a relative directory path. Finally, we changed the directory to the parent directory of /Users/andrew/Desktop via cd .., back to /Users/andrew. The special directory symbol .. specifies the parent directory. How did we know that the Desktop/ folder is in /Users/andrew/? We can list all the files and directories within the current directory: andrew@MGQQR2YQRT9 ~ % ls Applications Desktop Documents Downloads Library Movies Music Pictures Public It is very common to navigate a directory tree via iterations of ls and cd on relative paths. 2.3.1 Exercise: explore the maze. Use cd and ls to explore the maze in cmd_exercises/maze, report back what you find! To examine a text file completely, use the cat command with the first argument be the text file name, such as: andrew@MGQQR2YQRT9 west % cat orca_J.txt Pod J To examine the first few lines of a text file, use the head command with the first argument to be the text file name. To examine the last few lines of a text file, use tail. To scroll through a text file, use less, and press q to quit. Hint: to save typing, use the tab button twice to complete filepaths you don’t know existed. 2.4 Mental Model 2: Treat text-based programs as functions The commands you have been using, pwd, cd, ls, and cat are actually computer programs! They are completely text-based: the program take in some text input, do something with the input, prints out or save something, and quits. There are other text-based programs that are more interactive while it is running, which we will see later: but for now, we will consider this schema for our programs. (We will use programs and commands interchangeably.) If you have done some programming yourself, you use functions to create programming expressions. A function has a name, takes in inputs, and then does something before optionally returning a output. Function machine from algebra class. Similarly, when using a command from the command line, we should treat it as a function: a command has a name, inputs in terms of options and/or arguments, and optionally returns something. See below for an example of running the ls command with some options and arguments. Figure from Software Carpentry. We have been calling ls with no argument and options, and it outputs the files and folders in the current working directory. The command can take an optional argument of a folder path (full or relative), and it outputs the files and folders in that directory: andrew@MGQQR2YQRT9 Intro_to_Command_Line % ls / Applications System Volumes cores etc opt sbin usr Library Users bin dev home private tmp var We add the option -F: andrew@MGQQR2YQRT9 Intro_to_Command_Line % ls -F / Applications/ System/ Volumes/ cores/ etc@ opt/ sbin/ usr/ Library/ Users/ bin/ dev/ This displays a slash (‘/’) immediately after each pathname that is a directory, and (‘@’) after a symbolic link (not important to know right now). It is sometimes easy to overlook that the text printed from a command like ls is indeed the returned output from the program. It is important to keep this in mind when we start to use multiple commands together later in this seminar. 2.4.1 Subcommands Sometimes, a piece of software have many uses, like a swiss army knife. The software might organize its use by using subcommands. For instance, the software git has several subcommands such as git clone, git commit, and so forth. The usual options and arguments follow the subcommand. 2.4.2 How do we know what options and arguments to use for a command? If the command is built-in (not externally installed), then there is usually a manual for it. Use the man command, with argument of the command you want to look up: man ls and you will get comprehensive options and arguments to consider. Notice that here, man is the command, and ls is an argument for the command! Press q to exit the manual. Often, for externally installed software, there is a --help or -h option that tells you how to use the software. For instance, if Python 3 is installed on your computer: python3 --help Online resources: https://explainshell.com/ 2.4.3 Exercise: options for ls In the maze, try out a bunch of ways to list files and directories using various options of ls. Some questions to explore: Can you sort by last modified? Can you show the long format? What is the long format? What are hidden files? Are there any hidden files in the maze? (This requires some googling. The manual is not clear on this.) How can you use multiple options at once? Can you print out the entire maze directory tree by using a recursive option? 2.5 Putting the two mental models together: file manipulation Here are some commands that allows you to create, move, copy, and delete files and folders. All of these commands have no return value. cp [old] [new] copies a file or folder from the [old] path to a [new] folder. mv [old] [new] moves a file or folder from the [old] path to a [new] folder. mkdir [folderPath] creates a new folder at the path specified by [folderPath]. rm [path] deletes a file at [path]. rm -r [folder] deletes a folder and its subcontents. Cannot be undone unless there is a backup system (usually not on personal computers, but available on FH’s computing cluster.) There is a another special directory symbol that come up often in copying and moving. If you want to copy a file to the current directory, specify the working directory via .. For example, cp my_folder/file.txt . copies the file to the working directory. Can you explain what I am doing below? clo2@MGQQR2YQRT9 cmd_exercises % cd maze/west/ clo2@MGQQR2YQRT9 west % ls clam_1.txt clam_4.txt orca_L.txt seaweed_3.txt seaweed_6.txt clam_2.txt orca_J.txt seaweed_1.txt seaweed_4.txt seaweed_rotten.txt clam_3.txt orca_K.txt seaweed_2.txt seaweed_5.txt clo2@MGQQR2YQRT9 west % mkdir fish_net clo2@MGQQR2YQRT9 west % mv orca_J.txt fish_net clo2@MGQQR2YQRT9 west % ls clam_1.txt clam_4.txt orca_L.txt seaweed_3.txt seaweed_6.txt clam_2.txt fish_net seaweed_1.txt seaweed_4.txt seaweed_rotten.txt clam_3.txt orca_K.txt seaweed_2.txt seaweed_5.txt clo2@MGQQR2YQRT9 west % ls fish_net orca_J.txt clo2@MGQQR2YQRT9 west % cp fish_net/orca_J.txt . clo2@MGQQR2YQRT9 west % ls clam_1.txt clam_4.txt orca_K.txt seaweed_2.txt seaweed_5.txt clam_2.txt fish_net orca_L.txt seaweed_3.txt seaweed_6.txt clam_3.txt orca_J.txt seaweed_1.txt seaweed_4.txt seaweed_rotten.txt clo2@MGQQR2YQRT9 west % ls fish_net orca_J.txt clo2@MGQQR2YQRT9 west % rm fish_net/orca_J.txt clo2@MGQQR2YQRT9 west % rm -r fish_net 2.5.1 Wildcards to access multiple files Suppose that I want to move all the files starting with the characters orca in the maze/west directory. I could run mv command multiple times, but that is time consuming if I have a lot of such files. In the Shell, there are special wildcard symbols that allows you to access multiple files of a specific pattern: The * wildcard represents zero or more characters of any form. Therefore, orca* will specify all files that have orca starting in its file name: clo2@MGQQR2YQRT9 west % ls -l orca* -rw-r--r-- 1 clo2 staff 6 Aug 28 12:56 orca_J.txt -rw-r--r-- 1 clo2 staff 6 Aug 25 15:56 orca_K.txt -rw-r--r-- 1 clo2 staff 6 Aug 25 15:56 orca_L.txt The input argument for ls is now a list of files. We move it: clo2@MGQQR2YQRT9 west % mkdir fish_net clo2@MGQQR2YQRT9 west % mv orca* fish_net The wildcard can be used in different part of the filename to specify different files: We can use * to specify all files in a directory (undoing what we did before): clo2@MGQQR2YQRT9 west % mv fish_net/* . Or just files that have the number 2: clo2@MGQQR2YQRT9 west % ls -l *2* -rw-r--r-- 1 clo2 staff 0 Aug 28 13:21 clam_2.txt -rw-r--r-- 1 clo2 staff 0 Aug 28 13:18 seaweed_2.txt The ? wildcard represents exactly 1 character of any form: clo2@MGQQR2YQRT9 west % ls -l clam_?.txt -rw-r--r-- 1 clo2 staff 0 Aug 28 13:21 clam_1.txt -rw-r--r-- 1 clo2 staff 0 Aug 28 13:21 clam_2.txt -rw-r--r-- 1 clo2 staff 0 Aug 28 13:21 clam_3.txt -rw-r--r-- 1 clo2 staff 0 Aug 28 13:21 clam_4.txt 2.6 Applying what we just learned: running bioinformatics software Go to cmd_exercises/bioinformatics/. Download and install the following software via the following commands: git clone https://github.com/lh3/bwa.git cd bwa make To check that you installed bwa correctly, run the software: ./bwa The appendix describes why we used ./bwa instead of bwa to run the software. Go to downloaded_from_sequencing/ and take a look at the .fastq file using the commands cat, less, head, and tail. This is a high-throughput sequencing file, containing unaligned DNA sequences. Don’t worry about that the files don’t make sense to you. The point is that you can explore the text files using these commands. Go to reference_genome/ and take a look at miniReference.fasta using the commands as above. This is a (fake) reference human genome file. We will take the unaligned DNA sequences from the .fastq files and figure out where they align in the reference genome. Go back to bwa/. Let’s align the fastq file to the reference genome! ./bwa mem [reference genome fasta file] [unaligned sequences fastq file] If it works, you will get a wall of text ending with something like: HWI-ST745_0098:1:1101:11685:2579#0 4 * 0 0 * * 0 0 ATCTGAGGGGACGAGAGGGTAAGATGATTGATGGAGGGGAAATCCACAGAGCCTCAGGCACCAAATATGTAGCAAA GHHHHHHHHHHHHHHFGGGCGGEFGHHHGHEHHHHHHHGFFB;FGHHFHBHHHHGHGBE6FG&gt;BDGG6BFDACD@D AS:i:0 XS:i:0 [main] Version: 0.7.17-r1198-dirty [main] CMD: ./bwa mem ../reference_genome/miniReference.fasta ../downloaded_from_sequencing/test.fastq [main] Real time: 0.307 sec; CPU: 0.172 sec Nice job! 2.7 Bonus: Redirects and Pipes The ./bwa mem command seems pretty messy - it just dumps an aligned sequencing file in your command line console - what do you do with it? If you look at its manual, there is no option or argument to specify an output file name, which is a bit not user-friendly at first. However, in the CLI world, this is a perfectly normal way to output a result from a program. We simply need to redirect that output to a file ourselves. The output of ./bwa mem and the output of ls can be redirected to a file, via the &gt; operation: ./bwa mem [reference genome fasta file] [unaligned sequences fastq file] &gt; [output file] Remember when we looked at the output of the ls command, an emphasis is placed that the files and directories listed are considered the output of the program. We can redirect that output into a file too: ls &gt; ls_output.txt Another reason why in the CLI world the output is often dumped to the console is that it gives the user an option to pipe it to the next program that takes the first program’s output as input, using the symbol |. This allows the user to chain together several programs together, each performing a modular task. For instance, if we want to align the sequences, and then look at the last few aligned sequences, we can pipe the output of bwa mem with tail: ./bwa mem [reference genome fasta file] [unaligned sequences fastq file] | tail and then save it: ./bwa mem [reference genome fasta file] [unaligned sequences fastq file] | tail &gt; [output file] This encourages the development of modular, flexible programs that can be connected together via pipes and saved via redirecting. 2.8 Appendix: Special symbols for directories: . the current directory. .. the parent directory. / the root directory. ~ the home directory. 2.9 Appendix: Why do we run some programs using ./? 2.10 Appendix: using a text editor in CLI 2.11 Session info You should print out session info when you have code for reproducibility purposes. devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-09-08 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["about-the-authors.html", "About the Authors", " About the Authors These credits are based on our course contributors table guidelines.     Credits Names Pedagogy Lead Content Instructor(s) FirstName LastName Lecturer(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved Delivered the course in some way - video or audio Content Author(s) (include chapter name/link in parentheses if only for specific chapters) - make new line if more than one chapter involved If any other authors besides lead instructor Content Contributor(s) (include section name/link in parentheses) - make new line if more than one section involved Wrote less than a chapter Content Editor(s)/Reviewer(s) Checked your content Content Director(s) Helped guide the content direction Content Consultants (include chapter name/link in parentheses or word “General”) - make new line if more than one chapter involved Gave high level advice on content Acknowledgments Gave small assistance to content but not to the level of consulting Production Content Publisher(s) Helped with publishing platform Content Publishing Reviewer(s) Reviewed overall content and aesthetics on publishing platform Technical Course Publishing Engineer(s) Helped with the code for the technical aspects related to the specific course generation Template Publishing Engineers Candace Savonen, Carrie Wright, Ava Hoffman Publishing Maintenance Engineer Candace Savonen Technical Publishing Stylists Carrie Wright, Ava Hoffman, Candace Savonen Package Developers (ottrpal) Candace Savonen, John Muschelli, Carrie Wright Art and Design Illustrator(s) Created graphics for the course Figure Artist(s) Created figures/plots for course Videographer(s) Filmed videos Videography Editor(s) Edited film Audiographer(s) Recorded audio Audiography Editor(s) Edited audio recordings Funding Funder(s) Institution/individual who funded course including grant number Funding Staff Staff members who help with funding   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-09-08 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["references.html", "Chapter 3 References", " Chapter 3 References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
